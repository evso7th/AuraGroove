# EtherMusic: Технический обзор проекта

## 1. Концепция и архитектура

**EtherMusic** — это веб-приложение, созданное как "нейро-медитативный звуковой процессор". Цель проекта — предоставить пользователю интуитивный инструмент для создания эмбиент-музыки и медитативных звуковых ландшафтов без необходимости в музыкальном образовании.

Приложение построено на современном технологическом стеке, обеспечивающем высокую производительность, интерактивность и качественный звук в браузере.

### Технологический стек:

*   **Фреймворк:** Next.js (React) с App Router.
*   **UI:** ShadCN UI (компоненты на базе Radix UI) и Tailwind CSS для стилизации.
*   **Звуковой движок:** Tone.js — основная библиотека для синтеза и обработки звука в реальном времени.
*   **Язык:** TypeScript для строгой типизации и улучшения качества кода.
*   **Асинхронные вычисления:** Web Workers для выноса генерации музыки из основного потока.

## 2. Эволюция звукового движка: Квест за чистым звуком

Архитектура звукового движка — это сердце приложения. Она прошла несколько этапов эволюции в борьбе за производительность и чистоту звука, особенно на мобильных устройствах. Этот путь является ключевым для понимания текущей структуры кода.

### Акт 1: Иллюзия простоты и ловушка `PolySynth`

**Проблема:** Изначально для обработки полифонической игры использовался `Tone.PolySynth`. Это высокоуровневая абстракция, которая удобна для быстрого прототипирования, но имеет существенные недостатки в реальных условиях:
*   **Накладные расходы:** Создает значительную нагрузку на процессор.
*   **Артефакты звука ("Хрип"):** На мобильных устройствах или при интенсивной игре это приводило к главному врагу любого аудио-приложения — щелчкам, хрипам и задержкам звука.

**Вывод:** `PolySynth` не подходит для приложений, где требуется высокая производительность и отзывчивость.

### Акт 2: Архитектурная битва — Армия моносинтезаторов в пуле

**Решение:** Мы полностью отказались от `PolySynth` в пользу архитектуры **пула независимых моносинтезаторов (`Tone.Synth`)**, которая является стандартом в профессиональных аудио-приложениях.

**Как это работает:**
1.  **Инициализация:** При запуске `AudioEngine` создает и заранее инициализирует фиксированное количество одноголосых синтезаторов (`Voice` в нашей терминологии) для каждой партии ручной игры (мелодия, бас).
2.  **Распределение голосов:** Когда требуется извлечь ноту, движок находит свободный синтезатор в соответствующем пуле, "захватывает" его, и он начинает звучать. После окончания ноты он освобождается и возвращается в пул.

**Результат:** Это решение полностью устранило проблемы с производительностью на уровне синтеза и обеспечило кристально чистый, отзывчивый звук. Битва была выиграна, но не война.

### Акт 3: Новый враг — Тирания Главного Потока

**Проблема:** Несмотря на оптимизацию синтеза, появился новый враг — **"фризы" интерфейса**. Вся логика генерации музыки для автопилота выполнялась в основном потоке (main thread) JavaScript. Когда автопилот генерировал сложные музыкальные партии, это приводило к интенсивным вычислениям, которые "замораживали" основной поток. Анимации останавливались, а интерфейс переставал отвечать на действия пользователя.

**Вывод:** Любые ресурсоемкие, постоянные вычисления должны быть вынесены из основного потока.

### Акт 4: Финальное решение — Изоляция через Web Worker

**Архитектурное решение:** Мы перешли на архитектуру, где **вся логика автопилота для всех стилей вынесена в единый, изолированный Web Worker**.

**Как это работает:**
1.  **Разделение ответственности:**
    *   **Основной поток (`page.tsx` + `AudioEngine.ts`):** Отвечает только за UI и *исполнение* звуковых команд. Он не думает, *что* играть. Он просто получает готовые "партитуры".
    *   **Web Worker (`autopilot-worker.ts`):** Отвечает только за *генерацию* музыки. Он живет в своем собственном потоке, получает команды (например, "сменить стиль на Space") и отправляет обратно готовые ноты с точным временем их воспроизведения.
2.  **Обмен сообщениями:** Связь между потоками происходит через `postMessage`.
3.  **Оптимизация (Batching):** Чтобы не перегружать канал связи, Worker отправляет ноты не по одной, а **пакетами (`playNotesBatch`)**, например, целую арпеджированную последовательность за раз.

**Результат:** Эта архитектура полностью решила проблемы с производительностью. Интерфейс остается на 100% отзывчивым даже при самых сложных аранжировках автопилота. Это стабильная и масштабируемая модель, являющаяся ключом к успеху приложения.

## 3. Архитектура и Алгоритмы Автопилота

Это самая важная часть системы. "Мозг" автопилота (`autopilot-worker.ts`) работает в отдельном потоке и отвечает за композицию музыки. Он не производит звук, а лишь отправляет точные инструкции (партитуры) в основной поток для `AudioEngine`.

### 3.1. Основные принципы

*   **Тик (Tick):** `AudioEngine` с помощью `Tone.Transport.scheduleRepeat` отправляет в Worker сообщение `'tick'` каждые 16-ю долю ноты. Это сердцебиение всей системы. Все алгоритмы привязаны к этому тику.
*   **Гармония:** Worker хранит массив доступных частот для каждой партии (`scaleFrequencies`), который обновляется при смене тональности или лада. Это гарантирует, что вся сгенерированная музыка всегда гармонична.
*   **Партии:** Все стили генерируют ноты для партий: `bass`, `accompaniment`, `melody`, `effects`.

### 3.2. Алгоритмы стилей

#### Стиль: `Ambient`
*   **Концепция:** Медленные, обволакивающие звуковые ландшафты. Основа — плавно сменяющиеся аккорды и спокойная, предсказуемая мелодия.
*   **Бас:** Играет длинную ноту (дроун) в основе текущего аккорда. Смена ноты происходит раз в 2 такта.
*   **Аккомпанемент:** Играет 3-х нотный аккорд (трезвучие) в среднем регистре. Ноты аккорда запускаются с минимальной задержкой друг от друга, создавая эффект "мягкого" арпеджио или медленного взятия аккорда.
*   **Мелодия:** Играет одну длинную ноту раз в такт. Ключевая особенность — **пошаговое движение**. Следующая нота всегда находится на одну ступень лада выше или ниже предыдущей. Это создает простую, но логичную и "нескучную" мелодическую линию.
*   **Эволюция:** Достигается за счет медленной смены аккордов в рамках заданной прогрессии (`I-V-vi-IV`) и плавного "блуждания" мелодии по гамме.

#### Стиль: `Sequence` (вдохновлен Майком Олдфилдом)
*   **Концепция:** Гипнотические, повторяющиеся, но постоянно изменяющиеся арпеджио и секвенции.
*   **Бас:** Играет ритмичный пульс (раз в пол-ноты), последовательно перебирая ноты гаммы вверх.
*   **Аккомпанемент:** Играет более быстрое арпеджио (раз в четверть ноты), также двигаясь по гамме. Иногда "перепрыгивает" через несколько нот, чтобы сбить монотонность.
*   **Мелодия:** Работает по принципу **фраз и пауз**. Генерируется короткая мелодическая фраза из 3-5 нот, после чего следует пауза. Ноты внутри фразы также движутся преимущественно пошагово. Длина фраз и пауз постоянно варьируется.
*   **Эволюция:** Создается за счет асинхронного движения трех независимых секвенций (бас, аккомпанемент, мелодия) с разной скоростью, что порождает постоянно меняющиеся созвучия. Фразировка мелодии добавляет "человечности".

#### Стиль: `Water`
*   **Концепция:** Эффект "капель воды" и переливов.
*   **Бас:** Играет дроун, меняя ноту раз в 2 такта, создавая гармоническую основу.
*   **Аккомпанемент:** Это "сердце" стиля. Раз в 2 такта генерируется целый такт (16 нот) быстрого арпеджио, основанного на текущем аккорде. Паттерн арпеджио фиксирован, но каждый раз он проигрывается от новой басовой ноты.
*   **Мелодия:** Редкие, отдельные ноты-"капли", которые проигрываются со случайной вероятностью в верхнем регистре.
*   **Эволюция:** За счет смены басовой ноты, весь каскад арпеджио в аккомпанементе меняет свою гармонию, создавая ощущение "волн" или "кругов на воде".

#### Стиль: `Air`
*   **Концепция:** Легкость, пространство, "дыхание" музыки.
*   **Ключевая логика:** **Фразы и общие паузы**. Вся генерация (кроме аккомпанемента) то активна в течение 2-4 тактов, то полностью замолкает на 1-2 такта. Это создает ощущение "вдоха и выдоха".
*   **Бас:** Играет не постоянно, а по заранее заданным ритмическим рисункам (синкопированным или ровным), которые меняются с каждой новой фразой.
*   **Аккомпанемент:** Играет длинные, протяжные аккорды, которые меняются раз в 2 такта, создавая воздушную "подушку".
*   **Мелодия:** Играет легкое арпеджио в ритм основной пульсации, но только во время активных фраз.
*   **Эволюция:** Главный двигатель — смена фаз "активности" и "тишины". Смена ритмического рисунка баса и арпеджио в мелодии с каждой новой фразой не дает заскучать.

#### Стили: `Toccata` и `Promenade`
*   **Концепция:** Дань уважения классической музыке. Стили начинаются с проигрывания знаменитой темы, а затем переходят в генеративный режим, выдержанный в духе произведения.
*   **`Toccata`:** После вступления (Бах, Токката и фуга ре-минор) переходит в режим очень быстрых, виртуозных арпеджио в мелодии на фоне мощных, протяжных басовых нот.
*   **`Promenade`:** После темы "Прогулки" (Мусоргский, "Картинки с выставки") переходит в режим величественной, "шагающей" музыки с более медленным темпом и акцентом на аккордовые созвучия.
*   **Эволюция:** После проигрывания вступления, алгоритм использует ноты из той же тональности (ре-минор для Токкаты, си-мажор для Променада) для создания вариаций в заданном характере.

#### Стиль: `Space`
*   **Концепция:** Космическая бесконечность, таинственность.
*   **Бас:** Создает медленный, ритмичный пульс, который задает основу.
*   **Аккомпанемент:** Играет быстрое, гипнотическое арпеджио (16-ми нотами), которое постоянно повторяется, создавая ощущение движения. Гармония меняется раз в 4 такта.
*   **Эффекты:** С большой, но случайной задержкой проигрываются отдельные ноты специальным инструментом "effects", имитируя звук "космических лучей" или "метеоров".
*   **Эволюция:** За счет очень медленной смены гармонии в арпеджио и редких, непредсказуемых эффектов создается ощущение медленного полета через огромное пространство.

## 4. Обзор ключевых модулей

*   **`AudioEngine.ts`:** "Сердце" приложения. Управляет пулами синтезаторов для ручной игры, а также отдельными синтезаторами для каждой партии автопилота. Обрабатывает все каналы (`Tone.Channel`), эффекты (`Tone.Reverb`, `Tone.Delay`) и воспроизведение звуков как от ручной игры, так и от команд из Worker'а. Управляет записью сессии.
*   **`autopilot-worker.ts`:** "Мозг" приложения. Живет в отдельном потоке. Содержит всю логику для генерации музыкальных стилей ('Ambient', 'Toccata' и т.д.).
*   **`DrumMachine.ts`:** Отвечает за ритм-секцию. Использует `Tone.Players` (сэмплы) для качественного звука и `Tone.Part` для точного планирования паттернов.
*   **`page.tsx`:** Главный React-компонент. Является "единым источником правды" (Single Source of Truth) для всего состояния UI (громкость, активные паттерны, выбранные инструменты). Он передает команды в `AudioEngine` и Worker через `useEffect`.
*   **`LatchEngine.ts`:** Управляет логикой "удержания" нот на басовом пэде.

## 5. Сценарии использования

*   **Полностью ручная игра:** Пользователь отключает автопилот и ударные и играет на обоих термен-пэдах, используя Latch-режим для удержания басовых нот.
*   **Игра с ритм-секцией:** Пользователь включает один из паттернов ударных и импровизирует под него.
*   **Игра с автопилотом (сотворчество):** Пользователь включает автопилот и может играть на мелодическом пэде вместе с ним. Ноты пользователя будут гармонично вплетаться в общую канву.
*   **Режим прослушивания:** Пользователь включает автопилот и ударные, выбирает стиль и просто слушает сгенерированную музыку как бесконечный медитативный трек.

## 6. Замечание о размере проекта

В процессе разработки можно заметить, что папка проекта (в частности, директория `node_modules`) занимает значительный объем дискового пространства. **Это абсолютно нормально для современных веб-проектов.** При выполнении команды `npm run build`, Next.js собирает **оптимизированную, статическую версию приложения** в папку `out`, размер которой составляет всего несколько мегабайт.
