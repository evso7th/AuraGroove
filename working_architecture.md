# AuraGroove: Архитектурный паспорт (версия "Дирижер-Композитор")

Этот документ описывает стабильную, рабочую архитектуру проекта, достигнутую после решения проблем с производительностью и синхронизацией. Она является "золотым стандартом" для дальнейшей разработки.

## 1. Ключевая концепция: "Дирижер-Композитор"

В основе системы лежит строгое разделение ответственности между **Основным потоком (UI)** и **Web Worker'ом**, что является единственным способом обеспечить плавный интерфейс и сложную генерацию музыки одновременно.

-   **Дирижер (Основной поток):** Отвечает **только за время и исполнение**. Он не знает, *что* играть. Его задача — вовремя "взмахивать палочкой" и раздавать готовые ноты "музыкантам".
-   **Композитор (Web Worker):** Отвечает **только за сочинение музыки**. Он не знает, *когда* ее играть. Он пассивно ждет команды от "дирижера", чтобы сгенерировать партитуру на следующий такт.

Эта архитектура исключает ресурсоемкую генерацию из основного потока и избавляет воркер от ненадежных внутренних таймеров (`setInterval`).

## 2. Основной поток (UI Thread) — "Дирижер"

**Файлы:** `src/contexts/audio-engine-context.tsx`

**Задачи:**

1.  **Единый источник времени:** Владеет главным объектом `Tone.Transport`. Это — метроном и сердце всего приложения.
2.  **Управление циклом:** При инициализации создает `Tone.Loop`, который привязан к `Tone.Transport` и срабатывает каждый такт (`'1m'`).
3.  **Отправка команд:** Единственная задача этого цикла (`Loop`) — отправлять в Web Worker короткую команду `{ command: 'tick' }`. Эта операция сверхлегкая и не влияет на производительность UI.
4.  **Получение партитур:** Асинхронно слушает сообщения от воркера. Ожидает получить сообщение типа `{ type: 'score', data: {...} }`.
5.  **Делегирование исполнения:** Получив объект партитуры (`data`), немедленно передает соответствующие массивы нот (`data.drumScore`, `data.soloScore` и т.д.) специализированным менеджерам.
6.  **Планирование:** Использует `Tone.Transport.scheduleOnce()` для планирования воспроизведения полученной партитуры на **следующий** такт. Это гарантирует бесшовное воспроизведение без пауз и щелчков.

**Важно:** Основной поток **никогда** не занимается генерацией нот, мелодий или аккордов.

## 3. Web Worker — "Композитор"

**Файл:** `src/lib/ambient.worker.ts`

**Задачи:**

1.  **Пассивность:** Воркер полностью пассивен и не содержит собственных таймеров (`setInterval`, `setTimeout` для цикла). Он запускает генерацию **только** в ответ на команду `tick` из основного потока.
2.  **Синхронная генерация:** При получении команды `tick`, он **синхронно** выполняет метод `Scheduler.tick()`.
3.  **Оркестровка генераторов:** `Scheduler` действует как внутренний дирижер для самого воркера. Он поочередно вызывает методы у `EvolutionEngine` (и других потенциальных генераторов) для создания партий для каждого инструмента.
4.  **Сборка партитуры:** Все сгенерированные массивы нот собираются в единый объект `messageData`.
5.  **Отправка результата:** Готовый объект `messageData` отправляется в основной поток через `self.postMessage({ type: 'score', data: messageData });`.

**Важно:** Воркер не имеет доступа к `Tone.js` и оперирует только чистыми данными (массивы объектов с нотами, временем, длительностью).

## 4. Менеджеры синтезаторов — "Исполнители"

**Файлы:** `src/lib/*-synth-manager.ts` (например, `accompaniment-synth-manager.ts`)

**Задачи:**

1.  **Инкапсуляция `Tone.js`:** Каждый менеджер является фасадом для соответствующего `Tone.js`-инструмента (например, `Tone.PolySynth`). Он скрывает сложность настройки и взаимодействия с `Tone.js`.
2.  **Получение партитуры:** Имеет публичный метод `schedule(score: SynthNote[], time: number)`.
3.  **Воспроизведение:** Внутри метода `schedule` он перебирает массив нот и использует `triggerAttackRelease` для их воспроизведения в указанное `time` с нужной длительностью и громкостью.

## 5. Особенность стиля "Evolve": Аккорды с "живым" исполнением

Для достижения плотного, но чистого звучания аккомпанемента, мы используем прием "микросдвига":

-   **Генерация в воркере:** `EvolutionEngine.generateAccompanimentScore` генерирует ноты аккорда (например, 'C4', 'E4', 'G4').
-   **Микросдвиг:** Время начала каждой ноты в аккорде смещается на крошечную величину (`time: timeOffset + (index * 0.02)`).
-   **Исполнение:** `AccompanimentSynthManager` получает эти почти одновременные ноты и его `Tone.PolySynth` воспроизводит их как очень быстрое арпеджио.
-   **Результат:** На слух это воспринимается как единый, гармонически плотный аккорд, но "взятый" мягко, без резкой атаки. Этот подход также критически важен для производительности, так как он распределяет пиковую нагрузку на процессор во времени, предотвращая щелчки и артефакты звука.

Эта архитектура является надежной, масштабируемой и решает все ключевые проблемы, с которыми мы сталкивались.