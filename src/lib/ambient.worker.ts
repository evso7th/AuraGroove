

/**
 * @file AuraGroove Ambient Music Worker
 *
 * This worker operates on a microservice-style architecture.
 * It is the "Sound Engine", responsible for both composing and rendering audio.
 */
import type { DrumNote, SynthNote, WorkerCommand, WorkerSettings, DrumSampleName, InstrumentSettings, ScoreName, AudioProfile, MelodyTechnique } from '@/types/music';

// --- 1. PatternProvider (The Music Sheet Library) ---
const PatternProvider = {
    drumPatterns: {
        ambient_beat: [
            { sample: 'kick' as DrumSampleName, time: 0, velocity: 1.0 },
            { sample: 'hat' as DrumSampleName, time: 1.0, velocity: 0.3 },
            { sample: 'snare' as DrumSampleName, time: 2.0, velocity: 0.8 },
            { sample: 'hat' as DrumSampleName, time: 3.0, velocity: 0.3 },
        ],
        composer: [], // This will be dynamically generated by the EvolutionEngine
        none: []
    },
    getDrumPattern(name: keyof typeof PatternProvider.drumPatterns): DrumNote[] {
        return this.drumPatterns[name] || [];
    },
};

// --- 2. Instrument Generators (The Composers) ---
class EvolutionEngine {
    private chordProgression: { root: string; notes: string[] }[];
    private lastMelodyNoteIndex: number = 0;
    
    // Voice allocation state for melody
    private readonly MELODY_VOICE_COUNT = 3;
    private melodyVoiceReleaseTimes: number[] = new Array(this.MELODY_VOICE_COUNT).fill(0);


    constructor() {
        this.chordProgression = [
            { root: 'C2', notes: ['C3', 'E3', 'G3'] },    // I (C Major)
            { root: 'A1', notes: ['A2', 'C3', 'E3'] },    // vi (A Minor)
            { root: 'F1', notes: ['F2', 'A2', 'C3'] },    // IV (F Major)
            { root: 'G1', notes: ['G2', 'B2', 'D3'] },    // V (G Major)
        ];
        this.reset();
    }
    
    public reset() {
        console.log('[WORKER] EvolutionEngine Reset.');
        this.lastMelodyNoteIndex = 0;
        this.melodyVoiceReleaseTimes.fill(0);
    }

    generateComposerDrumScore(bar: number, volume: number): DrumNote[] {
        const score: DrumNote[] = [];
        
        score.push({ sample: 'kick', time: 0, velocity: 1.0 * volume });
        score.push({ sample: 'snare', time: 2.0, velocity: 0.7 * volume });

        const hatPattern = bar % 4;
        switch(hatPattern) {
            case 0:
                score.push({ sample: 'hat', time: 0.5, velocity: 0.4 * volume });
                score.push({ sample: 'hat', time: 1.5, velocity: 0.4 * volume });
                score.push({ sample: 'hat', time: 2.5, velocity: 0.4 * volume });
                score.push({ sample: 'hat', time: 3.5, velocity: 0.4 * volume });
                break;
            case 1: 
                for(let i=0; i<4; i++) {
                    score.push({ sample: 'hat', time: i + 0.5, velocity: 0.3 * volume });
                }
                break;
            case 2:
                 score.push({ sample: 'hat', time: 0.75, velocity: 0.35 * volume });
                 score.push({ sample: 'hat', time: 1.5, velocity: 0.35 * volume });
                 score.push({ sample: 'hat', time: 2.25, velocity: 0.35 * volume });
                 score.push({ sample: 'hat', time: 3.75, velocity: 0.35 * volume });
                break;
            case 3:
                if(bar % 8 < 4) {
                    score.push({ sample: 'ride', time: 1.0, velocity: 0.5 * volume });
                    score.push({ sample: 'ride', time: 3.0, velocity: 0.5 * volume });
                } else {
                    score.push({ sample: 'hat', time: 1.0, velocity: 0.4 * volume });
                    score.push({ sample: 'hat', time: 3.0, velocity: 0.4 * volume });
                }
                break;
        }

        if (bar % 8 === 0) {
            score.push({ sample: 'crash', time: 0, velocity: 0.6 * volume });
        }
        
        return score;
    }


    // "Harmony Breath"
    generateBassScore(bar: number, settings: WorkerSettings): SynthNote[] {
        const instrumentName = settings.instrumentSettings?.bass?.name;
        if (instrumentName === 'none') return [];
        
        const volume = settings.instrumentSettings?.bass?.volume ?? 0.7;
        
        // Change chord every 2 bars
        if (bar % 2 !== 0) return [];
        
        const currentChord = this.chordProgression[Math.floor(bar / 2) % this.chordProgression.length];
        
        const score: SynthNote[] = [
            // One long, 8-beat note (2 measures)
            { note: currentChord.root, duration: 8.0, time: 0, velocity: volume },
        ];

        return score;
    }

    // "Lullaby" - Updated for techniques
    generateMelodyScore(bar: number, settings: WorkerSettings, currentBarTime: number): SynthNote[] {
        const melodySettings = settings.instrumentSettings?.melody;
        if (melodySettings?.name === 'none') return [];

        const volume = melodySettings?.volume ?? 0.9;
        const technique = melodySettings?.technique ?? 'arpeggio';
        
        const score: SynthNote[] = [];
        const phraseLength = Math.floor(Math.random() * 2) + 2; // 2-3 notes per phrase
        const noteDuration = 4.0 / phraseLength; // Divide a measure into parts

        const currentChord = this.chordProgression[Math.floor(bar / 2) % this.chordProgression.length];
        const chordNotes = currentChord.notes;
        
        // Voice allocation logic for Arpeggio
        if (technique === 'arpeggio') {
            for (let i = 0; i < phraseLength; i++) {
                const noteTime = i * noteDuration;
                
                // Find an available voice
                let voiceIndex = -1;
                for (let v = 0; v < this.MELODY_VOICE_COUNT; v++) {
                    if (this.melodyVoiceReleaseTimes[v] <= currentBarTime + noteTime) {
                        voiceIndex = v;
                        break;
                    }
                }
                if (voiceIndex === -1) continue; // Skip note if no voice is free

                const note = chordNotes[ (this.lastMelodyNoteIndex + i) % chordNotes.length ];
                const releaseTime = 2.0; // Based on the synth preset's release
                
                score.push({
                    note: note,
                    duration: noteDuration * 1.5, // Allow overlap
                    time: noteTime,
                    velocity: volume,
                    voiceIndex: voiceIndex
                });
                
                // Book the voice
                this.melodyVoiceReleaseTimes[voiceIndex] = currentBarTime + noteTime + noteDuration + releaseTime;
            }
        } else { // Portamento / Glissando
            const voiceIndex = 0; // Use a single voice
            const phrase: string[] = [];
            for (let i = 0; i < phraseLength; i++) {
                 phrase.push(chordNotes[(this.lastMelodyNoteIndex + i) % chordNotes.length]);
            }
            score.push({
                note: phrase,
                duration: 4.0, // Whole phrase lasts one measure
                time: 0,
                velocity: volume,
                voiceIndex: voiceIndex
            });
        }
        
        // Update the starting point for the next phrase
        this.lastMelodyNoteIndex = (this.lastMelodyNoteIndex + 1) % chordNotes.length;

        return score;
    }
}


// Dummy classes for parts that are not yet fully implemented, to avoid breaking changes.
class OmegaScoreGenerator {
    generateScore(bar: number, settings: any) { return { bassScore: [], melodyScore: [] }; }
}
class PromenadeScoreGenerator {
     generateScore(bar: number, settings: any) { return { bassScore: [], melodyScore: [] }; }
}

// --- 3. Scheduler (The Conductor) ---
const Scheduler = {
    barCount: 0,
    
    settings: {
        bpm: 75,
        score: 'evolve' as ScoreName,
        drumSettings: { pattern: 'ambient_beat', volume: 0.5, enabled: true },
        instrumentSettings: { 
            bass: { name: "portamento", volume: 0.45 },
            melody: { name: "synth", volume: 0.45, technique: 'arpeggio' as MelodyTechnique },
        },
    } as WorkerSettings,

    evolutionEngine: new EvolutionEngine(),
    omegaEngine: new OmegaScoreGenerator(),
    promenadeEngine: new PromenadeScoreGenerator(),


    // Calculated properties
    get beatsPerBar() { return 4; },
    get secondsPerBeat() { return 60 / this.settings.bpm; },
    get barDuration() { return this.beatsPerBar * this.secondsPerBeat; },

    reset() {
      this.barCount = 0;
      this.evolutionEngine.reset();
      self.postMessage({ type: 'started' });
    },
    
    updateSettings(newSettings: Partial<WorkerSettings>) {
        if (newSettings.drumSettings) this.settings.drumSettings = { ...this.settings.drumSettings, ...newSettings.drumSettings };
        if (newSettings.instrumentSettings) this.settings.instrumentSettings = { ...this.settings.instrumentSettings, ...newSettings.instrumentSettings };
        if (newSettings.bpm) this.settings.bpm = newSettings.bpm;
        if (newSettings.score) this.settings.score = newSettings.score;
    },

    // This is now only called when the main thread commands it.
    tick() {
        console.log(`[WORKER] Scheduler.tick called for bar ${this.barCount}`);
        let drumScore: DrumNote[] = [];
        let bassScore: SynthNote[] = [];
        let melodyScore: SynthNote[] = [];
        const currentBarTime = this.barCount * this.barDuration;

        if (this.settings.drumSettings.enabled) {
            const pattern = this.settings.drumSettings.pattern;
            if (pattern === 'composer') {
                drumScore = this.evolutionEngine.generateComposerDrumScore(this.barCount, this.settings.drumSettings.volume);
            } else if (pattern === 'ambient_beat') {
                const staticPattern = PatternProvider.getDrumPattern('ambient_beat');
                drumScore = staticPattern.map(note => ({ ...note, velocity: note.velocity * this.settings.drumSettings.volume }));
            }
        }
        
        bassScore = this.evolutionEngine.generateBassScore(this.barCount, this.settings);
        melodyScore = this.evolutionEngine.generateMelodyScore(this.barCount, this.settings, currentBarTime);
       
        const messageData = {
            drumScore,
            bassScore,
            melodyScore,
            barDuration: this.barDuration,
        };
        
        console.log(`[WORKER] Posting score to main thread:`, messageData);
        self.postMessage({ type: 'score', data: messageData });
        
        this.barCount++;
    }
};


// --- MessageBus (The entry point) ---
self.onmessage = async (event: MessageEvent<WorkerCommand>) => {
    const { command, data } = event.data;
    console.log(`[WORKER] Received command: ${command}`);

    try {
        switch (command) {
            case 'init':
                Scheduler.reset();
                break;
            case 'tick':
                 Scheduler.tick();
                 break;
            case 'update_settings':
                 Scheduler.updateSettings(data);
                break;
            case 'reset':
                 Scheduler.reset();
                 break;
        }
    } catch (e) {
        self.postMessage({ type: 'error', error: e instanceof Error ? e.message : String(e) });
    }
};
