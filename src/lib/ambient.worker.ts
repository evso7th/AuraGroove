
/**
 * @file AuraGroove Ambient Music Worker
 *
 * This worker operates on a microservice-style architecture.
 * It is the "Sound Engine", responsible for both composing and rendering audio.
 */
import type { DrumNote, SynthNote, WorkerCommand, WorkerSettings, DrumSampleName, InstrumentSettings, ScoreName } from '@/types/music';

// --- 1. PatternProvider (The Music Sheet Library) ---
const PatternProvider = {
    drumPatterns: {
        ambient_beat: [
            { sample: 'kick' as DrumSampleName, time: 0, velocity: 1.0 },
            { sample: 'hat' as DrumSampleName, time: 0.5, velocity: 0.3 },
            { sample: 'snare' as DrumSampleName, time: 1.0, velocity: 0.8 },
            { sample: 'hat' as DrumSampleName, time: 1.5, velocity: 0.3 },
            { sample: 'kick' as DrumSampleName, time: 2.0, velocity: 0.9 },
            { sample: 'hat' as DrumSampleName, time: 2.5, velocity: 0.3 },
            { sample: 'snare' as DrumSampleName, time: 3.0, velocity: 0.7 },
            { sample: 'hat' as DrumSampleName, time: 3.5, velocity: 0.3 },
        ],
        composer: [], // This will be dynamically generated by the EvolutionEngine
        none: []
    },
    getDrumPattern(name: string): DrumNote[] {
        return this.drumPatterns[name as keyof typeof this.drumPatterns] || [];
    },
};

// --- 2. Instrument Generators (The Composers) ---
class EvolutionEngine {
    private accompanimentVoices: { note: string; releaseTime: number; }[] = [];
    private readonly MAX_ACCOMPANIMENT_VOICES = 4;
    private readonly TARGET_ACCOMPANIMENT_DENSITY = 2.5;
    
    private soloLastNote: string | null = 'C4';
    private readonly harmonyNotes = ['C4', 'D4', 'E4', 'G4', 'A4', 'C5', 'D5'];
    private readonly soloNotes = ['C4', 'D4', 'E4', 'G4', 'A4', 'C5', 'D5', 'E5'];

    private nextFillBar: number;
    private currentFillInterval: number;

    // Bass phrase management
    private bassPhraseLength: number;
    private maxBassPhraseLength: number;


    constructor() {
        this.reset();
    }
    
    private getNewMaxBassPhraseLength(): number {
        return Math.floor(Math.random() * (5 - 3 + 1)) + 3; // Random length from 3 to 5
    }
    
    public reset() {
        // Initialize with a random interval between 6 and 12 bars
        this.currentFillInterval = Math.floor(Math.random() * (12 - 6 + 1)) + 6;
        this.nextFillBar = this.currentFillInterval - 1;

        // Bass phrase initialization
        this.bassPhraseLength = 0;
        this.maxBassPhraseLength = this.getNewMaxBassPhraseLength();

        this.soloLastNote = 'C4';
        this.accompanimentVoices = [];
        console.log('[Worker EvolutionEngine] Reset.');
    }


    generateDrumScore(bar: number, settings: {volume: number}): DrumNote[] {
        const score: DrumNote[] = [];
        const vol = settings.volume;

        // Bass and Kick in unison
        score.push({ sample: 'kick', time: 0, velocity: 1.0 * vol });
        score.push({ sample: 'hat', time: 1, velocity: 0.4 * vol });
        score.push({ sample: 'snare', time: 2, velocity: 0.8 * vol });
        score.push({ sample: 'hat', time: 3, velocity: 0.4 * vol });

        // Simple fill with crash at a random interval
        if (bar === this.nextFillBar) {
             score.push({ sample: 'kick', time: 1, velocity: 0.7 * vol });
             // Replace snare with crash
             score[2] = { sample: 'crash', time: 3, velocity: 0.6 * vol };
             
             // Calculate the next fill
             this.currentFillInterval = Math.floor(Math.random() * (12 - 6 + 1)) + 6;
             this.nextFillBar += this.currentFillInterval;
        }

        return score;
    }
    
    generateAccompanimentScore(bar: number, settings: WorkerSettings, barDuration: number): SynthNote[] {
        const accompanimentSettings = settings.instrumentSettings?.accompaniment;
        if (accompanimentSettings?.name === 'none') return [];
        
        const score: SynthNote[] = [];
        const now = bar * barDuration;

        // 1. Clean up old notes
        this.accompanimentVoices = this.accompanimentVoices.filter(v => v.releaseTime > now);

        // 2. Generate new notes to maintain density
        let currentDensity = this.accompanimentVoices.length;
        
        for (let beat = 0; beat < 4; beat++) {
            if (currentDensity < this.TARGET_ACCOMPANIMENT_DENSITY && this.accompanimentVoices.length < this.MAX_ACCOMPANIMENT_VOICES) {
                if (Math.random() > 0.4) { // Don't add a note on every beat
                    const timeOffset = beat * (barDuration / 4);
                    const noteName = this.harmonyNotes[Math.floor(Math.random() * this.harmonyNotes.length)];
                    const duration = barDuration * (1.5 + Math.random());
                    
                    const newNote: SynthNote = {
                        note: noteName,
                        duration: duration,
                        time: beat, // time in beats
                        velocity: (0.4 + Math.random() * 0.2) * (accompanimentSettings?.volume ?? 0.7)
                    };
                    score.push(newNote);
                    this.accompanimentVoices.push({ note: newNote.note, releaseTime: now + timeOffset + duration });
                    currentDensity++;
                }
            }
        }
        return score;
    }
    
    generateSoloScore(bar: number, settings: WorkerSettings, barDuration: number): SynthNote[] {
        const soloSettings = settings.instrumentSettings?.solo;
        if (soloSettings?.name === 'none') return [];

        const score: SynthNote[] = [];

        // Generate a continuous melody line
        for (let beat = 0; beat < 4; beat++) {
            // Stepwise motion
            const lastNoteIndex = this.soloNotes.indexOf(this.soloLastNote || 'C4');
            let nextNoteIndex;
            if (lastNoteIndex === -1) {
                nextNoteIndex = Math.floor(this.soloNotes.length / 2);
            } else {
                const direction = Math.random() < 0.5 ? -1 : 1;
                nextNoteIndex = lastNoteIndex + direction;
            }

            // Boundary checks
            if (nextNoteIndex < 0) nextNoteIndex = 1;
            if (nextNoteIndex >= this.soloNotes.length) nextNoteIndex = this.soloNotes.length - 2;
            
            const nextNoteName = this.soloNotes[nextNoteIndex];
            this.soloLastNote = nextNoteName;

            const newNote: SynthNote = {
                note: nextNoteName,
                duration: barDuration / 2, // longer notes
                time: beat,
                velocity: (0.6 + Math.random() * 0.2) * (soloSettings?.volume ?? 0.8)
            };
            score.push(newNote);
        }

        return score;
    }

    generateBassScore(bar: number, settings: WorkerSettings): SynthNote[] {
        const instrumentName = settings.instrumentSettings?.bass?.name;
        if (instrumentName === 'none') {
            return [];
        }

        // Check if the phrase should end
        if (this.bassPhraseLength >= this.maxBassPhraseLength) {
            this.bassPhraseLength = 0;
            this.maxBassPhraseLength = this.getNewMaxBassPhraseLength();
            return []; // Return empty score for a pause
        }

        this.bassPhraseLength++;
        const volume = settings.instrumentSettings?.bass?.volume ?? 0.9;
        // Brighter, more positive I-vi progression
        const note = bar % 4 < 2 ? 'C2' : 'A1'; 
        
        return [{
            note: note,
            duration: 4, // Whole note duration in beats
            time: 0,
            velocity: 0.9 * volume
        }];
    }
}

// Dummy classes for parts that are not yet fully implemented, to avoid breaking changes.
class OmegaScoreGenerator {
    generateScore(bar: number, settings: any) { return []; }
}
class PromenadeScoreGenerator {
     generateScore(bar: number, settings: any) { return []; }
}

// --- 3. Scheduler (The Conductor) ---
const Scheduler = {
    barCount: 0,
    
    settings: {
        bpm: 75,
        score: 'evolve' as ScoreName,
        drumSettings: { pattern: 'ambient_beat', volume: 0.5, enabled: true },
        instrumentSettings: { 
            solo: { name: "none", volume: 0.8 },
            accompaniment: { name: "synthesizer", volume: 0.7 },
            bass: { name: "bassGuitar", volume: 0.45 },
        },
    } as WorkerSettings,

    evolutionEngine: new EvolutionEngine(),
    omegaEngine: new OmegaScoreGenerator(),
    promenadeEngine: new PromenadeScoreGenerator(),


    // Calculated properties
    get beatsPerBar() { return 4; },
    get secondsPerBeat() { return 60 / this.settings.bpm; },
    get barDuration() { return this.beatsPerBar * this.secondsPerBeat; },

    reset() {
      this.barCount = 0;
      this.evolutionEngine.reset();
      self.postMessage({ type: 'started' });
    },
    
    updateSettings(newSettings: Partial<WorkerSettings>) {
        if (newSettings.drumSettings) this.settings.drumSettings = { ...this.settings.drumSettings, ...newSettings.drumSettings };
        if (newSettings.instrumentSettings) this.settings.instrumentSettings = { ...this.settings.instrumentSettings, ...newSettings.instrumentSettings };
        if (newSettings.bpm) this.settings.bpm = newSettings.bpm;
        if (newSettings.score) this.settings.score = newSettings.score;
    },

    tick() {
        console.log(`[WORKER_TRACE] Scheduler.tick() called for bar ${this.barCount}`);
        let drumScore: DrumNote[] = [];
        let soloScore: SynthNote[] = [];
        let accompanimentScore: SynthNote[] = [];
        let bassScore: SynthNote[] = [];

        // Gradual instrument introduction
        if (this.barCount >= 0) {
            soloScore = this.evolutionEngine.generateSoloScore(this.barCount, this.settings, this.barDuration);
        }
        if (this.barCount >= 1 && this.settings.drumSettings.enabled) {
            if (this.settings.drumSettings.pattern === 'composer') {
               drumScore = this.evolutionEngine.generateDrumScore(this.barCount, this.settings.drumSettings);
           } else {
                drumScore = DrumGenerator.createScore(this.settings.drumSettings.pattern, this.barCount, this.settings.drumSettings);
           }
        }
        if (this.barCount >= 2) {
             bassScore = this.evolutionEngine.generateBassScore(this.barCount, this.settings);
        }
        if (this.barCount >= 3) {
            accompanimentScore = this.evolutionEngine.generateAccompanimentScore(this.barCount, this.settings, this.barDuration);
        }

        const messageData = {
            drumScore,
            soloScore,
            accompanimentScore,
            bassScore,
            barDuration: this.barDuration,
        };
        
        self.postMessage({ type: 'score', data: messageData });
        
        this.barCount++;
    }
};


// --- MessageBus (The entry point) ---
self.onmessage = async (event: MessageEvent<WorkerCommand>) => {
    const { command, data } = event.data;
    console.log(`[WORKER_TRACE] Received command: ${command}`);

    try {
        switch (command) {
            case 'init':
                Scheduler.reset();
                break;
            case 'tick':
                 Scheduler.tick();
                 break;
            case 'update_settings':
                 Scheduler.updateSettings(data);
                break;
            case 'reset':
                 Scheduler.reset();
                 break;
        }
    } catch (e) {
        self.postMessage({ type: 'error', error: e instanceof Error ? e.message : String(e) });
    }
};
