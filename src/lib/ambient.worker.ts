
/**
 * @file AuraGroove Ambient Music Worker
 *
 * This worker operates on a microservice-style architecture.
 * Each musical component is an isolated entity responsible for a single task.
 */

// --- Type Definitions for Worker Communication ---
type DrumNote = { sample: string; time: number; velocity: number; };
type StartData = {
    drumSettings: { pattern: string; volume: number, enabled: boolean };
    instrumentSettings: any;
    bpm: number;
    score: string;
};
type InitData = {
    samples: Record<string, ArrayBuffer>;
    sampleRate: number;
};


// --- 1. PatternProvider (The Music Sheet Library) ---
const PatternProvider = {
    drumPatterns: {
        ambient_beat: [
            { sample: 'kick', time: 0, velocity: 1.0 },
            { sample: 'hat', time: 0.5, velocity: 0.3 },
            { sample: 'snare', time: 1.0, velocity: 0.8 },
            { sample: 'hat', time: 1.5, velocity: 0.3 },
            { sample: 'kick', time: 2.0, velocity: 0.9 },
            { sample: 'hat', time: 2.5, velocity: 0.3 },
            { sample: 'snare', time: 3.0, velocity: 0.7 },
            { sample: 'hat', time: 3.5, velocity: 0.3 },
        ],
        composer: [
            // This will be dynamically generated by the EvolutionEngine
        ],
        none: []
    },
    getDrumPattern(name: string): Omit<DrumNote, 'time'>[] {
        return this.drumPatterns[name as keyof typeof this.drumPatterns] || [];
    },
};

// --- 2. Instrument Generators (The Composers) ---
class DrumGenerator {
    static createScore(patternName: string, barNumber: number, settings: { volume: number }): DrumNote[] {
        if (patternName === 'none') return [];
        const pattern = PatternProvider.getDrumPattern(patternName);
        let score = [...pattern];

        // Add a crash cymbal on the first beat of every 4th bar for ambient_beat
        if (patternName === 'ambient_beat' && barNumber % 4 === 0) {
            score = score.filter(note => note.time !== 0);
            score.push({ sample: 'crash', time: 0, velocity: 0.8 * settings.volume });
        }
        
        // Apply volume
        return score.map(note => ({...note, velocity: note.velocity * settings.volume}));
    }
}

// Fictional Evolution Engine for "composer" drum pattern
class EvolutionEngine {
    generateDrumScore(bar: number, settings: {volume: number}): DrumNote[] {
         if (bar % 2 === 0) {
            return [
                { sample: 'kick', time: 0, velocity: 1.0 * settings.volume },
                { sample: 'hat', time: 1, velocity: 0.4 * settings.volume },
                { sample: 'snare', time: 2, velocity: 0.8 * settings.volume },
                { sample: 'hat', time: 3, velocity: 0.4 * settings.volume },
            ];
         }
         return [
                { sample: 'kick', time: 0, velocity: 1.0 * settings.volume },
                { sample: 'hat', time: 1.5, velocity: 0.3 * settings.volume },
                { sample: 'kick', time: 2, velocity: 0.9 * settings.volume },
                { sample: 'snare', time: 3, velocity: 0.7 * settings.volume },
         ]
    }
}


// --- 3. Scheduler (The Conductor) ---
const Scheduler = {
    loopId: null as any,
    isRunning: false,
    barCount: 0,
    
    // Settings from main thread
    bpm: 120,
    drumSettings: { pattern: 'none', volume: 0.7, enabled: true },
    evolutionEngine: new EvolutionEngine(),

    // Calculated properties
    get beatsPerBar() { return 4; },
    get secondsPerBeat() { return 60 / this.bpm; },
    get barDuration() { return this.beatsPerBar * this.secondsPerBeat; },

    start(data: StartData) {
        if (this.isRunning) this.stop();
        this.updateSettings(data);
        this.barCount = 0;
        this.isRunning = true;
        
        // Schedule first tick, then repeat
        this.tick();
        this.loopId = setInterval(() => this.tick(), this.barDuration * 1000);
        self.postMessage({ type: 'started' });
    },

    stop() {
        if (!this.isRunning) return;
        clearInterval(this.loopId);
        this.loopId = null;
        this.isRunning = false;
        self.postMessage({ type: 'stopped' });
    },
    
    updateSettings(settings: any) {
        if (settings.drumSettings) this.drumSettings = { ...this.drumSettings, ...settings.drumSettings };
        if (settings.bpm) this.bpm = settings.bpm;
    },

    tick() {
        if (!this.isRunning) return;

        let drumScore: DrumNote[] = [];

        if (this.drumSettings.enabled && this.drumSettings.pattern !== 'none') {
            if (this.drumSettings.pattern === 'composer') {
                drumScore = this.evolutionEngine.generateDrumScore(this.barCount, this.drumSettings);
            } else {
                drumScore = DrumGenerator.createScore(this.drumSettings.pattern, this.barCount, this.drumSettings);
            }
        }
        
        // Add time relative to bar start
        const finalDrumScore = drumScore.map(note => ({
            ...note,
            time: note.time * this.secondsPerBeat
        }));
        
        console.log('[WORKER_TRACE] Posting "score" message with data:', { drumScore: finalDrumScore, barDuration: this.barDuration });
        self.postMessage({
            type: 'score',
            data: {
                drumScore: finalDrumScore,
                barDuration: this.barDuration,
            }
        });

        this.barCount++;
    }
};


// --- MessageBus (The entry point) ---
self.onmessage = async (event: MessageEvent) => {
    const { command, data } = event.data;

    try {
        switch (command) {
            case 'start':
                console.log('[WORKER_TRACE] Received "start" command with data:', data);
                Scheduler.start(data);
                break;
            case 'stop':
                Scheduler.stop();
                break;
            case 'update_settings':
                 Scheduler.updateSettings(data);
                break;
        }
    } catch (e) {
        self.postMessage({ type: 'error', error: e instanceof Error ? e.message : String(e) });
    }
};
