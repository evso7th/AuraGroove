
/**
 * @file AuraGroove Ambient Music Worker
 *
 * This worker operates on a microservice-style architecture.
 * It is the "Sound Engine", responsible for both composing and rendering audio.
 */
import type { DrumNote, SynthNote, WorkerCommand, WorkerSettings, DrumSampleName, InstrumentSettings, ScoreName } from '@/types/music';

// --- 1. PatternProvider (The Music Sheet Library) ---
const PatternProvider = {
    drumPatterns: {
        ambient_beat: [
            { sample: 'kick' as DrumSampleName, time: 0, velocity: 1.0 },
            { sample: 'hat' as DrumSampleName, time: 0.5, velocity: 0.3 },
            { sample: 'snare' as DrumSampleName, time: 1.0, velocity: 0.8 },
            { sample: 'hat' as DrumSampleName, time: 1.5, velocity: 0.3 },
            { sample: 'kick' as DrumSampleName, time: 2.0, velocity: 0.9 },
            { sample: 'hat' as DrumSampleName, time: 2.5, velocity: 0.3 },
            { sample: 'snare' as DrumSampleName, time: 3.0, velocity: 0.7 },
            { sample: 'hat' as DrumSampleName, time: 3.5, velocity: 0.3 },
        ],
        composer: [], // This will be dynamically generated by the EvolutionEngine
        none: []
    },
    getDrumPattern(name: string): DrumNote[] {
        return this.drumPatterns[name as keyof typeof this.drumPatterns] || [];
    },
};

// --- 2. Instrument Generators (The Composers) ---
class DrumGenerator {
    static createScore(patternName: string, barNumber: number, settings: { volume: number }): DrumNote[] {
        if (patternName === 'none') return [];
        const pattern = PatternProvider.getDrumPattern(patternName);
        let score = [...pattern];

        // Add a crash cymbal on the first beat of every 4th bar for ambient_beat
        if (patternName === 'ambient_beat' && barNumber % 4 === 0) {
            score = score.filter(note => note.time !== 0);
            score.push({ sample: 'crash', time: 0, velocity: 0.8 });
        }
        
        return score.map(note => ({...note, velocity: note.velocity * settings.volume}));
    }
}

class EvolutionEngine {
    generateDrumScore(bar: number, settings: {volume: number}): DrumNote[] {
         if (bar % 2 === 0) {
            return [
                { sample: 'kick', time: 0, velocity: 1.0 * settings.volume },
                { sample: 'hat', time: 1, velocity: 0.4 * settings.volume },
                { sample: 'snare', time: 2, velocity: 0.8 * settings.volume },
                { sample: 'hat', time: 3, velocity: 0.4 * settings.volume },
            ];
         }
         return [
                { sample: 'kick', time: 0, velocity: 1.0 * settings.volume },
                { sample: 'hat', time: 1.5, velocity: 0.3 * settings.volume },
                { sample: 'kick', time: 2, velocity: 0.9 * settings.volume },
                { sample: 'snare', time: 3, velocity: 0.7 * settings.volume },
         ]
    }
    
    // --- "Тибетские чаши" ---
    // Генерирует не аккорд, а последовательность одиночных нот (арпеджио),
    // чтобы избежать одновременной атаки нескольких звуков.
    generateAccompanimentScore(bar: number, settings: WorkerSettings, timeOffset: number): SynthNote[] {
        const instrumentName = settings.instrumentSettings?.accompaniment?.name;
        if (instrumentName === 'none') {
            return [];
        }

        const volume = settings.instrumentSettings?.accompaniment?.volume ?? 0.7;
        const notes = ['C4', 'E4', 'G4']; // Базовые ноты для арпеджио
        const score: SynthNote[] = [];

        notes.forEach((note, index) => {
            score.push({
                note: note,
                duration: 2, // Длинный release создаст эффект наложения
                time: timeOffset + (index * 0.5), // Ноты играются последовательно, а не одновременно
                velocity: 0.6 * volume,
            });
        });

        return score;
    }

    generateSoloScore(bar: number, settings: WorkerSettings, timeOffset: number): SynthNote[] {
        const instrumentName = settings.instrumentSettings?.solo?.name;
        if (instrumentName === 'none') {
            return [];
        }
         const volume = settings.instrumentSettings?.solo?.volume ?? 0.8;
         // Простая логика для примера
         if (bar % 4 === 2) {
            return [{
                note: 'B4',
                duration: 1,
                time: timeOffset,
                velocity: 0.8 * volume
            }];
         }
         return [];
    }
    
    generateBassScore(bar: number, settings: WorkerSettings, timeOffset: number): SynthNote[] {
        const instrumentName = settings.instrumentSettings?.bass?.name;
        if (instrumentName === 'none') {
            return [];
        }
        const volume = settings.instrumentSettings?.bass?.volume ?? 0.9;
        // Простая басовая нота в начале такта
        return [{
            note: 'C2',
            duration: 4,
            time: timeOffset,
            velocity: 1.0 * volume
        }];
    }
}

// Dummy classes for parts that are not yet fully implemented, to avoid breaking changes.
class OmegaScoreGenerator {
    generateScore(bar: number, settings: any) { return []; }
}
class PromenadeScoreGenerator {
     generateScore(bar: number, settings: any) { return []; }
}


// --- 3. SampleBank (Decoded Audio Storage) ---
// This is now simplified as it doesn't handle rendering, just data.
const SampleBank = {
    isInitialized: false,
    async init() {
        this.isInitialized = true;
    },
};

// --- 4. Scheduler (The Conductor) ---
const Scheduler = {
    loopId: null as any,
    isRunning: false,
    barCount: 0,
    
    settings: {
        bpm: 75,
        score: 'evolve' as ScoreName,
        drumSettings: { pattern: 'ambient_beat', volume: 0.7, enabled: true },
        instrumentSettings: { 
            solo: { name: "none", volume: 0.8 },
            accompaniment: { name: "synthesizer", volume: 0.7 },
            bass: { name: "none", volume: 0.9 },
        },
    } as WorkerSettings,

    evolutionEngine: new EvolutionEngine(),
    omegaEngine: new OmegaScoreGenerator(),
    promenadeEngine: new PromenadeScoreGenerator(),


    // Calculated properties
    get beatsPerBar() { return 4; },
    get secondsPerBeat() { return 60 / this.settings.bpm; },
    get barDuration() { return this.beatsPerBar * this.secondsPerBeat; },

    start(data: WorkerSettings) {
        if (this.isRunning) this.stop();
        this.updateSettings(data);
        this.barCount = 0;
        this.isRunning = true;
        
        this.tick(); 
        this.loopId = setInterval(() => this.tick(), this.barDuration * 1000);
        self.postMessage({ type: 'started' });
    },

    stop() {
        if (!this.isRunning) return;
        clearInterval(this.loopId);
        this.loopId = null;
        this.isRunning = false;
        self.postMessage({ type: 'stopped' });
    },
    
    updateSettings(newSettings: Partial<WorkerSettings>) {
        if (newSettings.drumSettings) this.settings.drumSettings = { ...this.settings.drumSettings, ...newSettings.drumSettings };
        if (newSettings.instrumentSettings) this.settings.instrumentSettings = { ...this.settings.instrumentSettings, ...newSettings.instrumentSettings };
        if (newSettings.bpm) this.settings.bpm = newSettings.bpm;
        if (newSettings.score) this.settings.score = newSettings.score;
    },

    tick() {
        if (!this.isRunning || !SampleBank.isInitialized) return;

        let drumScore: DrumNote[] = [];
        let soloScore: SynthNote[] = [];
        let accompanimentScore: SynthNote[] = [];
        let bassScore: SynthNote[] = [];

        if (this.settings.drumSettings.enabled) {
             if (this.settings.drumSettings.pattern === 'composer') {
                drumScore = this.evolutionEngine.generateDrumScore(this.barCount, this.settings.drumSettings);
            } else {
                 drumScore = DrumGenerator.createScore(this.settings.drumSettings.pattern, this.barCount, this.settings.drumSettings);
            }
        }
        
        // --- Микро-смещения для разведения атак во времени ---
        const BASS_OFFSET = 0;         // Бас играет точно в долю
        const ACCOMP_OFFSET = 0.125;   // Аккомпанемент играет с небольшой задержкой (32-я нота)
        const SOLO_OFFSET = 0.25;      // Соло играет с еще большей задержкой (16-я нота)
        
        switch(this.settings.score) {
            case 'evolve':
                bassScore = this.evolutionEngine.generateBassScore(this.barCount, this.settings, BASS_OFFSET);
                accompanimentScore = this.evolutionEngine.generateAccompanimentScore(this.barCount, this.settings, ACCOMP_OFFSET);
                soloScore = this.evolutionEngine.generateSoloScore(this.barCount, this.settings, SOLO_OFFSET);
                break;
            case 'omega':
                // Placeholder for Omega logic
                break;
            case 'promenade':
                 // Placeholder for Promenade logic
                break;
        }

        const messageData = {
            drumScore,
            soloScore,
            accompanimentScore,
            bassScore,
            barDuration: this.barDuration,
        };
        
        console.log('[WORKER_TRACE] Posting score:', messageData);
        self.postMessage({ type: 'score', data: messageData });
        
        this.barCount++;
    }
};


// --- MessageBus (The entry point) ---
self.onmessage = async (event: MessageEvent<WorkerCommand>) => {
    const { command, data } = event.data;

    try {
        switch (command) {
            case 'init':
                // We don't need to decode samples here anymore, just acknowledge.
                await SampleBank.init();
                break;
            case 'start':
                Scheduler.start(data);
                break;
            case 'stop':
                Scheduler.stop();
                break;
            case 'update_settings':
                 Scheduler.updateSettings(data);
                break;
        }
    } catch (e) {
        self.postMessage({ type: 'error', error: e instanceof Error ? e.message : String(e) });
    }
};
