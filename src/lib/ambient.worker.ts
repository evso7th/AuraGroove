
/**
 * @file AuraGroove Ambient Music Worker
 *
 * This worker operates on a microservice-style architecture.
 * Each musical component is an isolated entity responsible for a single task.
 */
import type { DrumNote, SynthNote } from '@/types/music';

// --- Type Definitions for Worker Communication ---
type StartData = {
    drumSettings: { pattern: string; volume: number, enabled: boolean };
    instrumentSettings: any;
    bpm: number;
    score: string;
};
type InitData = {
    samples: Record<string, ArrayBuffer>;
    sampleRate: number;
};


// --- 1. PatternProvider (The Music Sheet Library) ---
const PatternProvider = {
    drumPatterns: {
        ambient_beat: [
            { sample: 'kick', time: 0, velocity: 1.0 },
            { sample: 'hat', time: 0.5, velocity: 0.3 },
            { sample: 'snare', time: 1.0, velocity: 0.8 },
            { sample: 'hat', time: 1.5, velocity: 0.3 },
            { sample: 'kick', time: 2.0, velocity: 0.9 },
            { sample: 'hat', time: 2.5, velocity: 0.3 },
            { sample: 'snare', time: 3.0, velocity: 0.7 },
            { sample: 'hat', time: 3.5, velocity: 0.3 },
        ],
        composer: [
            // This will be dynamically generated by the EvolutionEngine
        ],
        none: []
    },
    getDrumPattern(name: string): Omit<DrumNote, 'time' | 'velocity'>[] {
        return this.drumPatterns[name as keyof typeof this.drumPatterns] || [];
    },
};

// --- 2. Instrument Generators (The Composers) ---
class DrumGenerator {
    static createScore(patternName: string, barNumber: number, settings: { volume: number }): Omit<DrumNote, 'time'>[] {
        if (patternName === 'none') return [];
        const pattern = PatternProvider.getDrumPattern(patternName);
        let score = [...pattern];

        // Add a crash cymbal on the first beat of every 4th bar for ambient_beat
        if (patternName === 'ambient_beat' && barNumber % 4 === 0) {
            score = score.filter(note => (note as any).time !== 0);
            score.push({ sample: 'crash' });
        }
        
        return score.map(note => ({...note, velocity: (note as any).velocity * settings.volume}));
    }
}

// Fictional Evolution Engine for "composer" drum pattern
class EvolutionEngine {
    generateDrumScore(bar: number, settings: {volume: number}): DrumNote[] {
         if (bar % 2 === 0) {
            return [
                { sample: 'kick', time: 0, velocity: 1.0 * settings.volume },
                { sample: 'hat', time: 1, velocity: 0.4 * settings.volume },
                { sample: 'snare', time: 2, velocity: 0.8 * settings.volume },
                { sample: 'hat', time: 3, velocity: 0.4 * settings.volume },
            ];
         }
         return [
                { sample: 'kick', time: 0, velocity: 1.0 * settings.volume },
                { sample: 'hat', time: 1.5, velocity: 0.3 * settings.volume },
                { sample: 'kick', time: 2, velocity: 0.9 * settings.volume },
                { sample: 'snare', time: 3, velocity: 0.7 * settings.volume },
         ]
    }
    
    generateAccompanimentScore(bar: number, settings: any): SynthNote[] {
        // For now, let's generate a simple C Major 7 chord at the start of each bar
        const isAccompanimentEnabled = settings.instrumentSettings?.accompaniment?.name !== 'none';
        if (!isAccompanimentEnabled) return [];

        const volume = settings.instrumentSettings?.accompaniment?.volume ?? 0.7;

        return [
            {
                note: ['C4', 'E4', 'G4', 'B4'],
                duration: '1m',
                time: 0,
                velocity: 0.6 * volume,
            }
        ];
    }
}


// --- 3. Scheduler (The Conductor) ---
const Scheduler = {
    loopId: null as any,
    isRunning: false,
    barCount: 0,
    
    // Settings from main thread
    bpm: 120,
    drumSettings: { pattern: 'none', volume: 0.7, enabled: true },
    instrumentSettings: {},
    evolutionEngine: new EvolutionEngine(),

    // Calculated properties
    get beatsPerBar() { return 4; },
    get secondsPerBeat() { return 60 / this.bpm; },
    get barDuration() { return this.beatsPerBar * this.secondsPerBeat; },

    start(data: StartData) {
        if (this.isRunning) this.stop();
        this.updateSettings(data);
        this.barCount = 0;
        this.isRunning = true;
        
        // Schedule first tick, then repeat
        this.tick();
        this.loopId = setInterval(() => this.tick(), this.barDuration * 1000);
        self.postMessage({ type: 'started' });
    },

    stop() {
        if (!this.isRunning) return;
        clearInterval(this.loopId);
        this.loopId = null;
        this.isRunning = false;
        self.postMessage({ type: 'stopped' });
    },
    
    updateSettings(settings: any) {
        if (settings.drumSettings) this.drumSettings = { ...this.drumSettings, ...settings.drumSettings };
        if (settings.instrumentSettings) this.instrumentSettings = { ...this.instrumentSettings, ...settings.instrumentSettings };
        if (settings.bpm) this.bpm = settings.bpm;
    },

    tick() {
        if (!this.isRunning) return;

        let drumScore: DrumNote[] = [];
        let accompanimentScore: SynthNote[] = [];

        if (this.drumSettings.enabled && this.drumSettings.pattern !== 'none') {
            if (this.drumSettings.pattern === 'composer') {
                drumScore = this.evolutionEngine.generateDrumScore(this.barCount, this.drumSettings);
            } else {
                 const pattern = PatternProvider.getDrumPattern(this.drumSettings.pattern);
                 drumScore = pattern.map(note => ({
                     ...note,
                     time: (note as any).time,
                     velocity: (note as any).velocity * this.drumSettings.volume
                 }));
            }
        }
        
        accompanimentScore = this.evolutionEngine.generateAccompanimentScore(this.barCount, { instrumentSettings: this.instrumentSettings });

        // Add time relative to bar start
        const finalDrumScore = drumScore.map(note => ({
            ...note,
            time: note.time * this.secondsPerBeat
        }));

        const finalAccompanimentScore = accompanimentScore.map(note => ({
            ...note,
            time: note.time * this.secondsPerBeat
        }));
        
        const messageData = {
            drumScore: finalDrumScore,
            accompanimentScore: finalAccompanimentScore,
            barDuration: this.barDuration,
        };

        console.log('[WORKER_TRACE] Posting "score" message with data:', messageData);
        self.postMessage({
            type: 'score',
            data: messageData
        });

        this.barCount++;
    }
};


// --- MessageBus (The entry point) ---
self.onmessage = async (event: MessageEvent) => {
    const { command, data } = event.data;

    try {
        switch (command) {
            case 'start':
                console.log('[WORKER_TRACE] Received "start" command with data:', data);
                Scheduler.start(data);
                break;
            case 'stop':
                Scheduler.stop();
                break;
            case 'update_settings':
                 Scheduler.updateSettings(data);
                break;
        }
    } catch (e) {
        self.postMessage({ type: 'error', error: e instanceof Error ? e.message : String(e) });
    }
};
