# AuraGroove: Архитектурный паспорт (версия "Единый Композитор")

Этот документ описывает стабильную, рабочую архитектуру проекта, достигнутую после решения проблем с производительностью и синхронизацией. Он является "золотым стандартом" для дальнейшей разработки и, что не менее важно, документирует наш путь, включая ошибочные решения, чтобы этот опыт не был утерян.

## 1. Тупиковые ветви и извлеченные уроки

Наш путь к чистому звуку не был прямым. Мы столкнулись с классическими проблемами веб-аудио, и некоторые первоначальные решения оказались ошибочными.

*   **Ловушка `Tone.PolySynth`:** Первоначальная архитектура использовала `Tone.PolySynth` для воспроизведения аккордов в аккомпанементе. Теоретически, это правильный инструмент. Практически, на мобильных устройствах это приводило к катастрофическим хрипам и артефактам звука. **Урок:** `PolySynth`, как и любой другой инструмент, создающий несколько звуков одновременно, вызывает пиковую нагрузку на CPU. Для критичных к производительности приложений его следует избегать. Любые попытки "оптимизировать" его настройки были обречены, так как проблема была не в настройках, а в самой сути одновременного синтеза.

*   **Ошибка имитации аккордов:** Первой реакцией на отказ от `PolySynth` была попытка имитировать аккорды быстрыми арпеджио. Это решило проблему производительности, но было музыкально неверным для нашего стиля. Эмбиент требует плавности и текучести, а не "дискотечных" арпеджио. **Урок:** Решение технической проблемы не должно идти вразрез с музыкальной концепцией.

## 2. Ключевая концепция: "Единый Композитор и Раздельные Исполнители"

Текущая архитектура основана на двух принципах: вынос всей логики в Web Worker и согласованность партий на уровне композиции, а не исполнения.

*   **Композитор (`EvolutionEngine` в `ambient.worker.ts`):** Это "мозг" и "дирижер оркестра текстур". Он больше не мыслит отдельными партиями. Его задача — **создать единую, согласованную партитуру**, управляя всеми голосами соло и аккомпанемента как единым целым. Он следит за общей плотностью звука, чтобы добиться непрерывного "обволакивающего одеяла", где постоянно звучат 2-3 ноты в разных фазах своей ADSR-огибающей.

*   **Исполнители (`*-synth-manager.ts`):** Это независимые "музыканты". Каждый из них (`SoloSynthManager`, `AccompanimentSynthManager`) управляет собственным, изолированным пулом легковесных `MonoSynth`. Они ничего не знают друг о друге и о сложности общей партитуры. Их задача проста: получить свой массив нот от Композитора и точно в срок его исполнить.

## 3. Решение проблемы производительности: "Асимметричный ответ"

Мы решили проблему хрипов не "в лоб", а асимметрично, изменив сам подход к композиции.

*   **Отказ от аккордов в пользу текстур:** Вместо того, чтобы играть 3 ноты одновременно, создавая пик нагрузки, Композитор теперь генерирует 3 монофонические линии, которые начинаются в разное время, но их звучание (за счет длинного `release`) перекрывается. Это создает необходимую гармоническую плотность и "обволакивающий" эффект без перегрузки процессора.

*   **"Бюджет голосов" (Жесткий контракт):** Это — гарантия стабильности системы. `AccompanimentSynthManager` имеет физическое ограничение (например, 4 `MonoSynth`). `EvolutionEngine` знает об этом "бюджете" и **никогда не сгенерирует партитуру, содержащую больше 4 нот**. Это простое правило полностью исключает риск переполнения пула голосов, возникновения очереди или "кражи" голосов.

## 4. Менеджеры-Исполнители: Принцип самодостаточности

Каждый "исполнитель" (`DrumMachine`, `SoloSynthManager` и т.д.) спроектирован как самодостаточный модуль, который инкапсулирует всю свою логику и предоставляет простой интерфейс для управления.

*   **`DrumMachine` и управление громкостью:** Для управления общей громкостью ударных мы не пытаемся изменять `velocity` каждого отдельного сэмпла в воркере. Это было бы излишне сложно и неправильно с точки зрения микширования. Вместо этого, `DrumMachine` инкапсулирует собственный `Tone.Channel`. Этот канал действует как единый "микшерный пульт" для всей установки ударных. Хук в основном потоке напрямую изменяет `volume` этого канала, что является чистым, производительным и архитектурно правильным решением.

Эта архитектура является надежной, масштабируемой и музыкально выразительной. Она позволяет создавать сложные, живые звуковые текстуры даже на устройствах с ограниченной мощностью.