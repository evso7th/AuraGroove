
<!DOCTYPE html>
<html>
<head>
    <title>Rhythm Frame</title>
    <script src="/assets/vendor/tone/Tone.js"></script>
</head>
<body>
    <script>
        console.log('[RHYTHM FRAME] HTML loaded.');

        let bassSynth;
        let drumMachine;
        let isInitialized = false;

        class DrumMachine {
            constructor(samples, callback) {
                console.log('[RHYTHM FRAME] Setting up instruments...');
                this.players = new Tone.Players(samples, {
                    onload: () => {
                        console.log('[RHYTHM FRAME] Drum samples loaded.');
                        callback(); // Notify that setup is complete
                    },
                    onerror: (error) => {
                         console.error('[RHYTHM FRAME] Error loading drum samples:', error);
                    },
                    baseUrl: '/assets/drums/'
                }).toDestination();
            }

            schedule(drumScore, time) {
                drumScore.forEach(note => {
                    const player = this.players.player(note.sample);
                    if (player) {
                        player.start(time + (note.time * (60 / Tone.Transport.bpm.value)), 0, undefined, 0, note.velocity);
                    }
                });
            }
        }


        async function setupInstruments() {
            if (isInitialized) return true;
            console.log('[RHYTHM FRAME] Setting up instruments...');
            bassSynth = new Tone.MonoSynth().toDestination();
            
            return new Promise((resolve) => {
                drumMachine = new DrumMachine({
                    kick: 'kick_drum6.wav',
                    snare: 'snare.wav',
                    hat: 'closed_hi_hat_accented.wav',
                    crash: 'crash1.wav',
                }, () => {
                     isInitialized = true;
                     console.log('[RHYTHM FRAME] Instruments are ready.');
                     resolve(true);
                });
            });
        }


        function scheduleScore(payload) {
             if (!isInitialized || !payload || !payload.score) return;
             
             const { score, bar } = payload;
             const time = Tone.now();
            
            // For now, schedule immediately. Later we will sync with transport.
             if (score.bassScore && score.bassScore.length > 0) {
                 const bassNote = score.bassScore[0];
                 bassSynth.triggerAttackRelease(bassNote.note, bassNote.duration, time, bassNote.velocity);
             }

             if (score.drumScore && score.drumScore.length > 0) {
                 drumMachine.schedule(score.drumScore, time);
             }
        }

        async function init() {
             if (isInitialized) return;
             console.log('[RHYTHM FRAME] Received init. Starting AudioContext...');
             await Tone.start();
             console.log('[RHYTHM FRAME] AudioContext started.');
             await setupInstruments();
             parent.postMessage({ type: 'rhythm_frame_ready' }, '*');
        }

        window.onmessage = (event) => {
            if (!event.data || !event.data.command) return;
            const { command, payload } = event.data;

            switch (command) {
                case 'init':
                    init();
                    break;
                case 'start':
                    if (isInitialized) Tone.Transport.start();
                    break;
                case 'stop':
                    if (isInitialized) Tone.Transport.stop();
                    break;
                case 'schedule':
                    scheduleScore(payload);
                    break;
                case 'set_param':
                    // Later for instrument/effect changes
                    break;
            }
        };
    </script>
</body>
</html>
