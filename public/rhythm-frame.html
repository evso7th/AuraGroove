
<!DOCTYPE html>
<html>
<head>
    <title>Rhythm Engine</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/15.0.4/Tone.js"></script>
    <script>
        // --- This script is the Rhythm Frame's core logic ---

        // Let the parent window know the frame is ready and Tone.js is loaded.
        window.onload = () => {
            console.log('[RHYTHM FRAME] Frame loaded, Tone.js available.');
            // We need to wait a moment for the parent to set up its listener
            setTimeout(() => {
                 parent.postMessage({ type: 'rhythm_frame_ready' }, '*');
            }, 100);
        };
        
        let hasAudioContextStarted = false;
        let scoreRequestLoop = null;
        let scheduledTime = 0;

        const channels = {
            drums: new Tone.Channel(-6).toDestination(),
            bass: new Tone.Channel(-6).toDestination(),
            melody: new Tone.Channel(-9).toDestination(), // Added for future use
        };

        const DRUM_SAMPLES = {
            'kick': '/assets/drums/kick_drum6.wav',
            'snare': '/assets/drums/snare.wav',
            'hat': '/assets/drums/closed_hi_hat_accented.wav',
            'crash': '/assets/drums/crash1.wav',
            'ride': '/assets/drums/cymbal1.wav',
        };

        class DrumMachine {
            sampler;
            isReady = false;

            constructor(channel) {
                this.sampler = new Tone.Players(DRUM_SAMPLES, () => {
                    this.isReady = true;
                }).connect(channel);
            }

            schedule(score, time) {
                if (!this.isReady || !score || score.length === 0) return;
                const barDuration = Tone.Time('1m').toSeconds();
                score.forEach(note => {
                    if (this.sampler.has(note.sample)) {
                        const noteTimeOffset = (note.time / 4) * barDuration;
                        const scheduleTime = time + noteTimeOffset;
                        this.sampler.player(note.sample).start(scheduleTime, 0, undefined, note.velocity);
                    }
                });
            }
        }

        class BassSynthManager {
            synths = {};
            activeInstrument = 'portamento';
            isPlaying = false;
            channel;

            constructor(channel) {
                this.channel = channel;
                this.createPresets();
                this.setInstrument(this.activeInstrument);
            }

            createPresets() {
                this.synths.portamento = new Tone.MonoSynth({
                    portamento: 0.2, 
                    oscillator: { type: 'fmsine' },
                    envelope: { attack: 0.1, decay: 0.3, sustain: 0.9, release: 4.0 },
                    filterEnvelope: { attack: 0.06, decay: 0.2, sustain: 0.5, release: 5.0, baseFrequency: 200, octaves: 7 }
                }).connect(this.channel);
            }
            
            getActiveSynth() {
                return this.synths[this.activeInstrument] || null;
            }

            setInstrument(name) {
               const currentSynth = this.getActiveSynth();
               if (this.isPlaying && currentSynth) {
                   currentSynth.triggerRelease();
                   this.isPlaying = false;
               }
               this.activeInstrument = name;
            }

            schedule(score, time) {
                const activeSynth = this.getActiveSynth();
                if (this.activeInstrument === 'none' || !activeSynth) {
                    if(this.isPlaying) activeSynth?.triggerRelease(time);
                    this.isPlaying = false;
                    return;
                }

                if (!score || score.length === 0) {
                    if (this.isPlaying) {
                        activeSynth.triggerRelease(time);
                        this.isPlaying = false;
                    }
                    return;
                }
                
                const barDuration = Tone.Time('1m').toSeconds();
                score.forEach(note => {
                    const noteTimeOffset = (note.time / 4) * barDuration;
                    const scheduledTime = time + noteTimeOffset;
                    const noteName = note.note;
                    
                     if (!this.isPlaying) {
                        activeSynth.triggerAttack(noteName, scheduledTime, note.velocity);
                        this.isPlaying = true;
                    } else {
                        activeSynth.setNote(noteName, scheduledTime);
                    }
                });
            }

            stopAll() {
                if (this.isPlaying) {
                    const activeSynth = this.getActiveSynth();
                    if (activeSynth) activeSynth.triggerRelease(Tone.now());
                    this.isPlaying = false;
                }
            }
        }

        let drumMachine;
        let bassManager;

        function startEngine() {
            if (Tone.Transport.state === 'started') return;
            
            parent.postMessage({ type: 'request_score' }, '*');
            scheduledTime = Tone.now() + 0.2; // Add latency

            scoreRequestLoop = new Tone.Loop(time => {
                parent.postMessage({ type: 'request_score' }, '*');
            }, '1m').start(0);

            Tone.Transport.start();
        }

        function stopEngine() {
            Tone.Transport.stop();
            scoreRequestLoop?.stop(0);
            bassManager?.stopAll();
        }

        window.addEventListener('message', async (event) => {
            if (!event.data || !event.data.command) return;

            const { command, payload } = event.data;

            if (command !== 'init' && !hasAudioContextStarted) {
                 await Tone.start();
                 hasAudioContextStarted = true;
            }

            if (command === 'init') {
                // This is now done on first load, but we keep the command for potential re-init
                return;
            }

            if (command === 'start') {
                if (!drumMachine) drumMachine = new DrumMachine(channels.drums);
                if (!bassManager) bassManager = new BassSynthManager(channels.bass);
                startEngine();
            } else if (command === 'stop') {
                stopEngine();
            } else if (command === 'schedule' && payload) {
                if (Tone.Transport.state !== 'started') return;

                drumMachine?.schedule(payload.drumScore, scheduledTime);
                bassManager?.schedule(payload.bassScore, scheduledTime);
                
                scheduledTime += payload.barDuration;

            } else if (command === 'set_param' && payload) {
                const { target, key, value } = payload;
                switch (target) {
                    case 'bass':
                        if (key === 'name') bassManager?.setInstrument(value);
                        if (key === 'volume') channels.bass.volume.value = Tone.gainToDb(value);
                        break;
                    case 'drums':
                        if (key === 'volume') channels.drums.volume.value = Tone.gainToDb(value);
                        break;
                    case 'transport':
                         if (key === 'bpm') Tone.Transport.bpm.value = value;
                        break;
                }
            }
        });
    </script>
</head>
<body>
    Rhythm Engine.
</body>
</html>
