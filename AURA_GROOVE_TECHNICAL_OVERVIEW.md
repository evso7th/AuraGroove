# AuraGroove: Технический обзор проекта (Финальная версия)

## 1. Ключевая архитектурная концепция: "Композитор в Воркере, Исполнители в Ворклетах"

Проект построен на асинхронной архитектуре, где логика **сочинения** музыки полностью отделена от логики **исполнения**, что обеспечивает максимальную производительность интерфейса и чистоту звука.

*   **Композитор (Web Worker - `src/lib/ambient.worker.ts`):** Это "мозг" приложения. Он работает в изолированном потоке и не занимается синтезом звука. Его задача — по команде `tick` из основного потока генерировать "партитуры" (массивы нот с точным временем) для всех инструментов. Он управляет плотностью аранжировки и выбором текстур (пэдов и "sparkles").

*   **Исполнители (AudioWorklet-процессоры - `public/worklets/*.js`):** Это "руки" приложения. Вместо ресурсоемкого `Tone.Synth` в основном потоке, мы используем легковесные процессоры, работающие напрямую в аудио-потоке с высокой производительностью.
    *   **`bass-processor.js` / `chord-processor.js`:** Получают команды (`noteOn`, `setPreset`) от своих менеджеров и генерируют звук с низкой задержкой. Они инкапсулируют сложную логику, такую как "пульс" или "арпеджио", выполняя ее самостоятельно, без необходимости в частых командах из основного потока.

*   **Менеджеры (Основной поток - `src/lib/*-manager.ts`):** Это "дирижеры" для ворклетов.
    *   `BassSynthManager` и `AccompanimentSynthManager` являются фасадами, которые управляют соответствующими `AudioWorkletNode`. Они транслируют команды на смену пресета или техники и передают ноты для исполнения.
    *   `DrumMachine`, `SparklePlayer`, `PadPlayer` используют нативный `AudioBufferSourceNode` для воспроизведения семплов, что также является высокопроизводительным решением.

## 2. Потоки данных и жизненный цикл команды

1.  **UI -> `useAuraGroove`:** Пользователь меняет настройку (например, BPM).
2.  **`useAuraGroove` -> `AudioEngineProvider`:** Хук вызывает `updateSettings`.
3.  **`AudioEngineProvider` -> Worker:** Контекст отправляет команду `{ command: 'update_settings', data: ... }` в `ambient.worker.ts`.
4.  **Worker (Композитор):** Воркер обновляет свое внутреннее состояние. В следующий `tick` он генерирует партитуру уже с учетом новых настроек.
5.  **Worker -> `AudioEngineProvider`:** Воркер отправляет готовую партитуру `{ type: 'score', score: {...} }` обратно.
6.  **`AudioEngineProvider` -> Менеджеры:** Контекст разбирает партитуру и делегирует массивы нот соответствующим менеджерам (`bassManager.schedule(...)`, `accompanimentManager.schedule(...)`).
7.  **Менеджеры -> Ворклеты (Исполнители):** Менеджеры отправляют команды (`noteOn`, `setMode`) в свои `AudioWorkletNode`, которые исполняют музыку.

## 3. Техники исполнения баса

Басовый синтезатор (`bass-processor.js`) поддерживает несколько техник исполнения, переключаемых из UI:

*   **Arpeggio:** Классическое арпеджио по нотам аккорда.
*   **Portamento/Glide/Glissando:** Плавное "скольжение" между нотами.
*   **Pulse:** При получении одной ноты, ворклет самостоятельно генерирует серию очень коротких и быстрых импульсов (1/32), создавая плотную, вибрирующую текстуру без нагрузки на основной поток.

## 4. Звуковые Текстуры

Для обогащения звукового ландшафта используются два типа текстур:

*   **Pads (`PadPlayer`):** Длинные, зацикленные фоновые звуки (эмбиент-пэды). При смене стиля происходит плавный 5-секундный кроссфейд между старым и новым пэдом.
*   **Sparkles (`SparklePlayer`):** Короткие, случайные звуковые эффекты ("искорки"), которые добавляют в музыку элемент неожиданности. Их частота появления зависит от параметра `density`.

## 5. Вывод

Финальная архитектура "AuraGroove" является зрелой, производительной и масштабируемой. Она эффективно решает классические проблемы веб-аудио, вынося всю ресурсоемкую работу из основного потока и используя современные `AudioWorklet` для синтеза звука. Это позволяет достичь богатого, сложного и чистого звучания даже на мобильных устройствах.
