# EtherMusic: Технический обзор проекта

## 1. Концепция и архитектура

**EtherMusic** — это веб-приложение, созданное как "нейро-медитативный звуковой процессор". Цель проекта — предоставить пользователю интуитивный инструмент для создания эмбиент-музыки и медитативных звуковых ландшафтов без необходимости в музыкальном образовании.

Приложение построено на современном технологическом стеке, обеспечивающем высокую производительность, интерактивность и качественный звук в браузере.

### Технологический стек:

*   **Фреймворк:** Next.js (React) с App Router.
*   **UI:** ShadCN UI (компоненты на базе Radix UI) и Tailwind CSS для стилизации.
*   **Звуковой движок:** Tone.js — основная библиотека для синтеза и обработки звука в реальном времени.
*   **Язык:** TypeScript для строгой типизации и улучшения качества кода.
*   **Асинхронные вычисления:** Web Workers для выноса генерации музыки из основного потока.

## 2. Эволюция звукового движка: Квест за чистым звуком

Архитектура звукового движка — это сердце приложения. Она прошла несколько этапов эволюции в борьбе за производительность и чистоту звука, особенно на мобильных устройствах. Этот путь является ключевым для понимания текущей структуры кода.

### Акт 1: Иллюзия простоты и ловушка `PolySynth`

**Проблема:** Изначально для обработки полифонической игры использовался `Tone.PolySynth`. Это высокоуровневая абстракция, которая удобна для быстрого прототипирования, но имеет существенные недостатки в реальных условиях:
*   **Накладные расходы:** Создает значительную нагрузку на процессор.
*   **Артефакты звука ("Хрип"):** На мобильных устройствах или при интенсивной игре это приводило к главному врагу любого аудио-приложения — щелчкам, хрипам и задержкам звука.

**Вывод:** `PolySynth` не подходит для приложений, где требуется высокая производительность и отзывчивость.

### Акт 2: Архитектурная битва — Армия моносинтезаторов в пуле

**Решение:** Мы полностью отказались от `PolySynth` в пользу архитектуры **пула независимых моносинтезаторов (`Tone.Synth`)**, которая является стандартом в профессиональных аудио-приложениях.

**Как это работает:**
1.  **Инициализация:** При запуске `AudioEngine` создает и заранее инициализирует фиксированное количество одноголосых синтезаторов (`Voice` в нашей терминологии) для каждой партии ручной игры (мелодия, бас).
2.  **Распределение голосов:** Когда требуется извлечь ноту, движок находит свободный синтезатор в соответствующем пуле, "захватывает" его, и он начинает звучать. После окончания ноты он освобождается и возвращается в пул.

**Результат:** Это решение полностью устранило проблемы с производительностью на уровне синтеза и обеспечило кристально чистый, отзывчивый звук. Битва была выиграна, но не война.

### Акт 3: Новый враг — Тирания Главного Потока

**Проблема:** Несмотря на оптимизацию синтеза, появился новый враг — **"фризы" интерфейса**. Вся логика генерации музыки для автопилота выполнялась в основном потоке (main thread) JavaScript. Когда автопилот генерировал сложные музыкальные партии, это приводило к интенсивным вычислениям, которые "замораживали" основной поток. Анимации останавливались, а интерфейс переставал отвечать на действия пользователя.

**Вывод:** Любые ресурсоемкие, постоянные вычисления должны быть вынесены из основного потока.

### Акт 4: Финальное решение — Изоляция через Web Worker

**Архитектурное решение:** Мы перешли на архитектуру, где **вся логика автопилота для всех стилей вынесена в единый, изолированный Web Worker**.

**Как это работает:**
1.  **Разделение ответственности:**
    *   **Основной поток (`page.tsx` + `AudioEngine.ts`):** Отвечает только за UI и *исполнение* звуковых команд. Он не думает, *что* играть. Он просто получает готовые "партитуры".
    *   **Web Worker (`autopilot-worker.ts`):** Отвечает только за *генерацию* музыки. Он живет в своем собственном потоке, получает команды (например, "сменить стиль на Space") и отправляет обратно готовые ноты с точным временем их воспроизведения.
2.  **Обмен сообщениями:** Связь между потоками происходит через `postMessage`.
3.  **Оптимизация (Batching):** Чтобы не перегружать канал связи, Worker отправляет ноты не по одной, а **пакетами (`playNotesBatch`)**, например, целую арпеджированную последовательность за раз.

**Результат:** Эта архитектура полностью решила проблемы с производительностью. Интерфейс остается на 100% отзывчивым даже при самых сложных аранжировках автопилота. Это стабильная и масштабируемая модель, являющаяся ключом к успеху приложения.

## 3. Обзор ключевых модулей

*   **`AudioEngine.ts`:** "Сердце" приложения. Управляет пулами синтезаторов для ручной игры, а также отдельными синтезаторами для каждой партии автопилота. Обрабатывает все каналы (`Tone.Channel`), эффекты (`Tone.Reverb`, `Tone.Delay`) и воспроизведение звуков как от ручной игры, так и от команд из Worker'а. Управляет записью сессии.
*   **`autopilot-worker.ts`:** "Мозг" приложения. Живет в отдельном потоке. Содержит всю логику для генерации музыкальных стилей ('Ambient', 'Toccata' и т.д.).
*   **`DrumMachine.ts`:** Отвечает за ритм-секцию. Использует `Tone.Players` (сэмплы) для качественного звука и `Tone.Part` для точного планирования паттернов.
*   **`page.tsx`:** Главный React-компонент. Является "единым источником правды" (Single Source of Truth) для всего состояния UI (громкость, активные паттерны, выбранные инструменты). Он передает команды в `AudioEngine` и Worker через `useEffect`.
*   **`LatchEngine.ts`:** Управляет логикой "удержания" нот на басовом пэде.

## 4. Сценарии использования

*   **Полностью ручная игра:** Пользователь отключает автопилот и ударные и играет на обоих термен-пэдах, используя Latch-режим для удержания басовых нот.
*   **Игра с ритм-секцией:** Пользователь включает один из паттернов ударных и импровизирует под него.
*   **Игра с автопилотом (сотворчество):** Пользователь включает автопилот и может играть на мелодическом пэде вместе с ним. Ноты пользователя будут гармонично вплетаться в общую канву.
*   **Режим прослушивания:** Пользователь включает автопилот и ударные, выбирает стиль и просто слушает сгенерированную музыку как бесконечный медитативный трек.

## 5. Новые возможности (v1.1.0)

*   **Запись сессии:** Возможность записать свою игру в файл формата `.webm`.
*   **Пресеты для автопилота:** Сохранение и загрузка уникальных настроек (инструменты, микшер) для каждого стиля автопилота.

## 6. Замечание о размере проекта

В процессе разработки можно заметить, что папка проекта (в частности, директория `node_modules`) занимает значительный объем дискового пространства. **Это абсолютно нормально для современных веб-проектов.** При выполнении команды `npm run build`, Next.js собирает **оптимизированную, статическую версию приложения** в папку `out`, размер которой составляет всего несколько мегабайт.